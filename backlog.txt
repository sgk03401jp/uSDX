























/*
class Encoder {
public:
  volatile int8_t val = 0;
  volatile int8_t step = 0;
  uint8_t last_state;
  Encoder(){
    pinMode(ROT_A, INPUT_PULLUP);
    pinMode(ROT_B, INPUT_PULLUP);
    PCMSK2 |= (1 << PCINT22) | (1 << PCINT23); // interrupt-enable for ROT_A,
ROT_B pin changes; see
https://github.com/EnviroDIY/Arduino-SDI-12/wiki/2b.-Overview-of-Interrupts
    PCICR |= (1 << PCIE2);
    last_state = (_digitalRead(ROT_B) << 1) | _digitalRead(ROT_A);
    sei();
  }
  void event(){
    switch(last_state = (last_state << 4) | (_digitalRead(ROT_B) << 1) |
_digitalRead(ROT_A)){ //transition  (see:
https://www.allaboutcircuits.com/projects/how-to-use-a-rotary-encoder-in-a-mcu-based-project/
) case 0x31: case 0x10: case 0x02: case 0x23: if(step < 0) step = 0; step++;
if(step >  3){ step = 0; val++; } break; case 0x32: case 0x20: case 0x01: case
0x13: if(step > 0) step = 0; step--; if(step < -3){ step = 0; val--; } break;
    }
  }
};
Encoder enc;
ISR(PCINT2_vect){  // Interrupt on rotary encoder turn
  enc.event();
}*/

// Short Sine table with 36 entries results in 1736Hz sine wave at effective
// sampling rate of 62500 SPS.
/* const int8_t sine[] = {
  22, 43, 64, 82, 97, 110, 119, 125, 127, 125, 119, 110, 97, 82, 64, 43, 22, 0,
-22, -43, -64, -82, -97, -110, -119, -125, -127, -125, -119, -110, -97, -82,
-64, -43, -22, 0
}; */

/*
// # M=3 .. = i0 + 3*(i2 + i3) + i1
int16_t i0, i1, i2, i3, i4, i5, i6, i7, i8;
int16_t q0, q1, q2, q3, q4, q5, q6, q7, q8;
#define M_SR  1

//#define EXPANDED_CIC
#ifdef EXPANDED_CIC
void sdr_rx_00(){         i0 = sdr_rx_common_i(); func_ptr = sdr_rx_01;   i4 =
(i0 + (i2 + i3) * 3 + i1) >> M_SR; } void sdr_rx_02(){         i1 =
sdr_rx_common_i(); func_ptr = sdr_rx_03;   i8 = (i4 + (i6 + i7) * 3 + i5) >>
M_SR; } void sdr_rx_04(){         i2 = sdr_rx_common_i(); func_ptr = sdr_rx_05;
i5 = (i2 + (i0 + i1) * 3 + i3) >> M_SR; } void sdr_rx_06(){         i3 =
sdr_rx_common_i(); func_ptr = sdr_rx_07; } void sdr_rx_08(){         i0 =
sdr_rx_common_i(); func_ptr = sdr_rx_09;   i6 = (i0 + (i2 + i3) * 3 + i1) >>
M_SR; } void sdr_rx_10(){         i1 = sdr_rx_common_i(); func_ptr = sdr_rx_11;
i8 = (i6 + (i4 + i5) * 3 + i7) >> M_SR; } void sdr_rx_12(){         i2 =
sdr_rx_common_i(); func_ptr = sdr_rx_13;   i7 = (i2 + (i0 + i1) * 3 + i3) >>
M_SR; } void sdr_rx_14(){         i3 = sdr_rx_common_i(); func_ptr = sdr_rx_15;
} void sdr_rx_15(){         q0 = sdr_rx_common_q(); func_ptr = sdr_rx_00;   q4 =
(q0 + (q2 + q3) * 3 + q1) >> M_SR; } void sdr_rx_01(){         q1 =
sdr_rx_common_q(); func_ptr = sdr_rx_02;   q8 = (q4 + (q6 + q7) * 3 + q5) >>
M_SR; } void sdr_rx_03(){         q2 = sdr_rx_common_q(); func_ptr = sdr_rx_04;
q5 = (q2 + (q0 + q1) * 3 + q3) >> M_SR; } void sdr_rx_05(){         q3 =
sdr_rx_common_q(); func_ptr = sdr_rx_06; process(i8, q8); } void sdr_rx_07(){ q0
= sdr_rx_common_q(); func_ptr = sdr_rx_08;   q6 = (q0 + (q2 + q3) * 3 + q1) >>
M_SR; } void sdr_rx_09(){         q1 = sdr_rx_common_q(); func_ptr = sdr_rx_10;
q8 = (q6 + (q4 + q5) * 3 + q7) >> M_SR; } void sdr_rx_11(){         q2 =
sdr_rx_common_q(); func_ptr = sdr_rx_12;   q7 = (q2 + (q0 + q1) * 3 + q3) >>
M_SR; } void sdr_rx_13(){         q3 = sdr_rx_common_q(); func_ptr = sdr_rx_14;
process(i8, q8); } #else void sdr_rx_00(){         i0 = sdr_rx_common_i();
func_ptr = sdr_rx_01;   i4 = (i0 + (i2 + i3) * 3 + i1) >> M_SR; } void
sdr_rx_02(){         i1 = sdr_rx_common_i(); func_ptr = sdr_rx_03;   i8 = (i4 +
(i6 + i7) * 3 + i5) >> M_SR; } void sdr_rx_04(){         i2 = sdr_rx_common_i();
func_ptr = sdr_rx_05;   i5 = (i2 + (i0 + i1) * 3 + i3) >> M_SR; } void
sdr_rx_06(){         i3 = sdr_rx_common_i(); func_ptr = sdr_rx_07;   i6 = i4; i7
= i5; q6 = q4; q7 = q5; } void sdr_rx_07(){         q0 = sdr_rx_common_q();
func_ptr = sdr_rx_00;   q4 = (q0 + (q2 + q3) * 3 + q1) >> M_SR; } void
sdr_rx_01(){         q1 = sdr_rx_common_q(); func_ptr = sdr_rx_02;   q8 = (q4 +
(q6 + q7) * 3 + q5) >> M_SR; } void sdr_rx_03(){         q2 = sdr_rx_common_q();
func_ptr = sdr_rx_04;   q5 = (q2 + (q0 + q1) * 3 + q3) >> M_SR; } void
sdr_rx_05(){         q3 = sdr_rx_common_q(); func_ptr = sdr_rx_06; process(i8,
q8); } #endif
*/

/*
static int16_t i_s0za1, i_s0za2, i_s0zb0, i_s0zb1, i_s1za1, i_s1za2, i_s1zb0,
i_s1zb1; static int16_t q_s0za1, q_s0za2, q_s0zb0, q_s0zb1, q_s1za1, q_s1za2,
q_s1zb0, q_s1zb1, q_ac2;

#define M_SR  0  // CIC N=2
void sdr_rx_00(){ int16_t ac = sdr_rx_common_i(); func_ptr = sdr_rx_01;  int16_t
i_s1za0 = (ac + i_s0za1 + i_s0zb0 * 2 + i_s0zb1) >> M_SR; i_s0za1 = ac; int16_t
ac2 = (i_s1za0 + i_s1za1 + i_s1zb0 * 2); i_s1za1 = i_s1za0; process(ac2, q_ac2);
} void sdr_rx_02(){ int16_t ac = sdr_rx_common_i(); func_ptr = sdr_rx_03;
i_s0zb0 = ac; } void sdr_rx_04(){ int16_t ac = sdr_rx_common_i(); func_ptr =
sdr_rx_05;  i_s1zb0 = (ac + i_s0za1 + i_s0zb0 * 2) >> M_SR; i_s0za1 = ac; } void
sdr_rx_06(){ int16_t ac = sdr_rx_common_i(); func_ptr = sdr_rx_07;  i_s0zb0 =
ac; } void sdr_rx_01(){ int16_t ac = sdr_rx_common_q(); func_ptr = sdr_rx_02;
q_s0zb0 = ac; } void sdr_rx_03(){ int16_t ac = sdr_rx_common_q(); func_ptr =
sdr_rx_04;  q_s1zb0 = (ac + q_s0za1 + q_s0zb0 * 2) >> M_SR; q_s0za1 = ac; } void
sdr_rx_05(){ int16_t ac = sdr_rx_common_q(); func_ptr = sdr_rx_06;  q_s0zb0 =
ac; } void sdr_rx_07(){ int16_t ac = sdr_rx_common_q(); func_ptr = sdr_rx_00;
int16_t q_s1za0 = (ac + q_s0za1 + q_s0zb0 * 2 + q_s0zb1) >> M_SR; q_s0za1 = ac;
q_ac2 = (q_s1za0 + q_s1za1 + q_s1zb0 * 2); q_s1za1 = q_s1za0; }
*/

/*
#define M_SR  2  // CIC N=3
static uint8_t nested = false;

void sdr_rx()
{
#ifdef TESTBENCH
 int16_t adc = NCO_I();
#else
 ADMUX = admux[1];  // set MUX for next conversion
 ADCSRA |= (1 << ADSC);    // start next ADC conversion
 int16_t adc = ADC - 511; // current ADC sample 10-bits analog input, NOTE:
first ADCL, then ADCH #endif func_ptr = sdr_rx_q;    // processing function for
next conversion sdr_rx_common();

 static int16_t prev_adc;
 int16_t corr_adc = (prev_adc + adc) / 2;  // Only for I: correct I/Q sample
delay by means of linear interpolation prev_adc = adc; adc = corr_adc;
 //static int16_t dc;
 //dc += (adc - dc) / 2;  // we lose LSB with this method
 //dc = (3*dc + adc)/4;
 //int16_t ac = adc - dc;     // DC decoupling
 int16_t ac = adc;

 static int16_t s0zb0, s0zb1;
 if(rx_state == 0 || rx_state == 4){  // stage s0: down-sample by 2
   static int16_t s0za1, s0za2;
   int16_t s1za0 = (ac + (s0za1 + s0zb0) * 3 + s0zb1) >> M_SR;           // FA +
FB
   //int16_t s1za0 = (ac + s0za1 * 6 + s0za2 + s0zb0 + s0zb1);
   //s0za2 = s0za1;
   s0za1 = ac;
   static int16_t s1zb0, s1zb1;
   if(rx_state == 0){                   // stage s1: down-sample by 2
     static int16_t s1za1, s1za2;
     int16_t ac2 = (s1za0 + (s1za1 + s1zb0) * 3 + s1zb1) >> M_SR; // FA + FB $
     //int16_t ac2 = (s1za0 + s1za1 * 6 + s1za2 + s1zb0 + s1zb1); // FA + FB $
     //s1za2 = s1za1; // $
     s1za1 = s1za0;
     {
       rx_state++;

       static int16_t ac3;
       static int16_t ozd1, ozd2;  // Output stage
       if(_init){ ac3 = 0; ozd1 = 0; ozd2 = 0; _init = 0; } // hack: on first
sample init accumlators of further stages (to prevent instability) int16_t od1 =
ac3 - ozd1; // Comb section ocomb = od1 - ozd2; interrupts(); ozd2 = od1; ozd1 =
ac3;

       //if(nested){ return; } // fuse for too many nested interrupts (prevent
stack overflow)
       //nested++;
       //interrupts();  // hack: post processing may be extend until next sample
time: allow next sample to be processed while postprocessing

       {
         q_ac2 >>= att2;  // digital gain control
         static int16_t v[14];  // Process Q (down-sampled) samples
         q = v[7];
         // Hilbert transform, BasicDSP model:  outi= fir(inl,  0, 0, 0, 0, 0,
0,  0, 1,   0, 0,   0, 0,  0, 0, 0, 0); outq = fir(inr, 2, 0, 8, 0, 21, 0, 79,
0, -79, 0, -21, 0, -8, 0, -2, 0) / 128; qh = ((v[0] - q_ac2) + (v[2] - v[12]) *
4) / 64 + ((v[4] - v[10]) + (v[6] - v[8])) / 8 + ((v[4] - v[10]) * 5 - (v[6] -
v[8]) ) / 128 + (v[6] - v[8]) / 2; // Hilbert transform, 43dB side-band
rejection in 650..3400Hz (@8kSPS) when used in image-rejection scenario;
(Hilbert transform require 4 additional bits)
         //qh = ((v[0] - q_ac2) * 2 + (v[2] - v[12]) * 8 + (v[4] - v[10]) * 21 +
(v[6] - v[8]) * 15) / 128 + (v[6] - v[8]) / 2; // Hilbert transform, 40dB
side-band rejection in 400..1900Hz (@4kSPS) when used in image-rejection
scenario; (Hilbert transform require 5 additional bits) v[0] = v[1]; v[1] =
v[2]; v[2] = v[3]; v[3] = v[4]; v[4] = v[5]; v[5] = v[6]; v[6] = v[7]; v[7] =
v[8]; v[8] = v[9]; v[9] = v[10]; v[10] = v[11]; v[11] = v[12]; v[12] = v[13];
v[13] = q_ac2;
       }
       ac2 >>= att2;  // digital gain control
       static int16_t v[7];  // Post processing I and Q (down-sampled) results
       i = v[0]; v[0] = v[1]; v[1] = v[2]; v[2] = v[3]; v[3] = v[4]; v[4] =
v[5]; v[5] = v[6]; v[6] = ac2;  // Delay to match Hilbert transform on Q branch
       ac3 = slow_dsp(i + qh);

       //nested--;
       return;
     }
   } else { s1zb1 = s1zb0; s1zb0 = s1za0; } // rx_state == 4 // *4
 } else { s0zb1 = s0zb0; s0zb0 = ac; }  // rx_state == 2 || rx_state == 6  // *4

 rx_state++;
}

void sdr_rx_q()
{
#ifdef TESTBENCH
 int16_t adc = NCO_Q();
#else
 ADMUX = admux[0];  // set MUX for next conversion
 ADCSRA |= (1 << ADSC);    // start next ADC conversion
 int16_t adc = ADC - 511; // current ADC sample 10-bits analog input, NOTE:
first ADCL, then ADCH #endif func_ptr = sdr_rx;    // processing function for
next conversion
 //sdr_rx_common();  //necessary? YES!... Maybe NOT!

 //static int16_t dc;
 //dc += (adc - dc) / 2;  // we lose LSB with this method
 //dc = (3*dc + adc)/4;
 //int16_t ac = adc - dc;     // DC decoupling
 int16_t ac = adc;

 static int16_t s0zb0, s0zb1;
 if(rx_state == 3 || rx_state == 7){  // stage s0: down-sample by 2
   static int16_t s0za1, s0za2;
   int16_t s1za0 = (ac + (s0za1 + s0zb0) * 3 + s0zb1) >> M_SR;           // FA +
FB
   //int16_t s1za0 = (ac + s0za1 * 6 + s0za2 + s0zb0 + s0zb1);
   //s0za2 = s0za1;
   s0za1 = ac;
   static int16_t s1zb0, s1zb1;
   if(rx_state == 7){                   // stage s1: down-sample by 2
     static int16_t s1za1, s1za2;
     q_ac2 = (s1za0 + (s1za1 + s1zb0) * 3 + s1zb1) >> M_SR; // FA + FB $
     //q_ac2 = (s1za0 + s1za1 * 6 + s1za2 + s1zb0 + s1zb1); // FA + FB $
     //s1za2 = s1za1; // $
     s1za1 = s1za0;
     rx_state = 0; return;
   } else { s1zb1 = s1zb0; s1zb0 = s1za0; } // rx_state == 3  // *4
 } else { s0zb1 = s0zb0; s0zb0 = ac; }  // rx_state == 1 || rx_state == 5  // *4

 rx_state++;
}

inline void sdr_rx_common()
{
 static int16_t ozi1, ozi2;
 if(_init){ ocomb=0; ozi1 = 0; ozi2 = 0; } // hack
 // Output stage [25% CPU@R=4;Fs=62.5k]
#ifdef SECOND_ORDER_DUC
 ozi2 = ozi1 + ozi2;          // Integrator section
#endif
 ozi1 = ocomb + ozi1;
#ifdef SECOND_ORDER_DUC
 OCR1AL = min(max((ozi2>>5) + 128, 0), 255);  // OCR1AL = min(max((ozi2>>5) +
ICR1L/2, 0), ICR1L);  // center and clip wrt PWM working range #else OCR1AL =
(ozi1>>5) + 128;
 // OCR1AL = min(max((ozi1>>5) + 128, 0), 255);  // OCR1AL = min(max((ozi2>>5) +
ICR1L/2, 0), ICR1L);  // center and clip wrt PWM working range #endif
}
*/

/* BACKLOG:
code definitions and re-use for comb, integrator, dc decoupling, arctan
refactor main()
agc based on rms256, agc/smeter after filter
noisefree integrator (rx audio out) in lower range
raised cosine tx amp for cw, 4ms tau seems enough:
http://fermi.la.asu.edu/w9cf/articles/click/index.html 32 bin fft dynamic range
cw att extended agc Split undersampling, IF-offset K2/TS480 CAT control faster
RX-TX switch to support CW usdx API demo code scan move last bit of arrays into
flash?
https://web.archive.org/web/20180324010832/https://www.microchip.com/webdoc/AVRLibcReferenceManual/FAQ_1faq_rom_array.html
u-law in RX path?:
http://dystopiancode.blogspot.com/2012/02/pcm-law-and-u-law-companding-algorithms.html
Arduino library?
1. RX bias offset correction by measurement avg, 2. charge decoupling cap. by
resetting to 0V and setting 5V for a certain amount of (charge) time add 1K
(500R?) to GND at TTL RF output to keep zero-level below BS170 threshold
additional PWM output for potential BOOST conversion
squelch gating
more buttons
s-meter offset vs DC bal.
keyer with interrupt-driven timers (to reduce jitter)

Analyse assembly:
/home/guido/Downloads/arduino-1.8.10/hardware/tools/avr/bin/avr-g++ -S -g -Os -w
-std=gnu++11 -fpermissive -fno-exceptions -ffunction-sections -fdata-sections
-fno-threadsafe-statics -Wno-error=narrowing -MMD -mmcu=atmega328p
-DF_CPU=16000000L -DARDUINO=10810 -DARDUINO_AVR_UNO -DARDUINO_ARCH_AVR
-I/home/guido/Downloads/arduino-1.8.10/hardware/arduino/avr/cores/arduino
-I/home/guido/Downloads/arduino-1.8.10/hardware/arduino/avr/variants/standard
/tmp/arduino_build_483134/sketch/QCX-SSB.ino.cpp -o
/tmp/arduino_build_483134/sketch/QCX-SSB.ino.cpp.txt

Rewire/code I/Q clk pins so that a Div/1 and Div/2 scheme is used instead of 0
and 90 degrees phase shift 10,11,13,12   10,11,12,13  (pin) Q- I+ Q+ I-   Q- I+
Q+ I- 90 deg.shift  div/2@S1(pin2)

50MHz LSB OK, USB NOK

atmega328p signature: https://forum.arduino.cc/index.php?topic=341799.15
https://www.eevblog.com/forum/microcontrollers/bootloader-on-smd-atmega328p-au/msg268938/#msg268938
https://www.avrfreaks.net/forum/undocumented-signature-row-contents

Alain k1fm AGC sens issue:  https://groups.io/g/ucx/message/3998
https://groups.io/g/ucx/message/3999 txdelay when vox is on (disregading the
tx>0 state due to ssb() overrule, instead use RX-digitalinput) Adrian: issue
#41, set cursor just after writing 'R' when smeter is off, and (menumode == 0)
Konstantinos: backup/restore vfofilt settings when changing vfo.
Bob: 2mA for clk0/1 during RX
Uli: accuracate voltages during diag

agc behind filter
vcc adc extend. power/curr measurement
swr predistort eff calc
block ptt while in vox mode

adc bias error and potential error correction
noise burst on tx
https://groups.io/g/ucx/topic/81030243#6265

for (size_t i = 0; i < 9; i++) id[i] = boot_signature_byte_get(0x0E + i + (i >
5));

// https://www.ti.com/lit/ds/symlink/ina226.pdf
#include <LiquidCrystal_I2C.h>
#include <Wire.h>
LiquidCrystal_I2C lcd(0x27, 20, 4);
#include <Adafruit_INA219.h>
Adafruit_INA219 ina219;
float pwr;
float Eff;
float Vinc, Vref = 0, SWR;
float k = 0.85;
float busvoltage = 0;
float current_mA = 0;
float power_mW = 0;

void setup() {
  ina219.begin();
  lcd.init();
  lcd.backlight();
}
void loop() {
  busvoltage = ina219.getBusVoltage_V();
  current_mA = ina219.getCurrent_mA();
  power_mW = ina219.getPower_mW();
  Vinc = analogRead(3);
  Vref = analogRead(2);
  SWR = (Vinc + Vref) / (Vinc - Vref);
  Vinc = ((Vinc * 5.0) / 1024.0) + 0.5;
  pwr = ((((Vinc) * (Vinc)) - 0.25 ) * k);
  Eff = (pwr) / ((power_mW) / 1000) * 100;
  if (pwr > 0 ) (pwr = pwr + 0.25);
  lcd.setCursor(0, 0);
  lcd.print("SWR     :1 / P     W");
  lcd.setCursor(4, 0);
  lcd.print(SWR);
  lcd.setCursor(15, 0);
  lcd.print(pwr);

  lcd.setCursor (0, 2);
  //lcd.print ("Vss = ");
  lcd.print(busvoltage);
  lcd.print("V  ");

  lcd.setCursor(8, 2);
  lcd.print (-((current_mA) / 1000));
  lcd.print("A  ");

  lcd.setCursor(15, 2);
  lcd.print((power_mW) / 1000);
  lcd.print("W   ");

  lcd.setCursor(0, 1);
  lcd.print("Efficiency = ");
  lcd.print(Eff);
  lcd.setCursor(17, 1);
  lcd.print("%   ");

  delay(300);
}
*/
/*
int8_t updateMode() // GW8RDI mod - relocated to function
{
  if (!menumode)
  {
    prev_mode = mode;
    if (rit) { rit = 0; stepsize = prev_stepsize[mode == CW]; change = true;
return -1; } mode += 1;    // Step thro modes
    //encoder_val = 1;
    //paramAction(UPDATE, MODE); // Mode param //paramAction(UPDATE, mode, NULL,
F("Mode"), mode_label, 0, _N(mode_label), true);
//#define MODE_CHANGE_RESETS  1
#ifdef MODE_CHANGE_RESETS
    if (mode != CW) stepsize = STEP_1k; else stepsize = STEP_500; // sets
suitable stepsize #endif if (mode > CW) mode = LSB;  // skip all other modes
(only LSB, USB, CW) #ifdef MODE_CHANGE_RESETS if (mode == CW) { filt = 4; nr =
0; } else filt = 0;  // resets filter (to most BW) and NR on mode change #else
    if (mode == CW) { nr = 0; }
    prev_stepsize[prev_mode == CW] = stepsize; stepsize = prev_stepsize[mode ==
CW]; // backup stepsize setting for previous mode, restore previous stepsize
setting for current selected mode; filter settings captured for either CQ or
other modes. prev_filt[prev_mode == CW] = filt; filt = prev_filt[mode == CW]; //
backup filter setting for previous mode, restore previous filter setting for
current selected mode; filter settings captured for either CQ or other modes.
#endif
    //paramAction(UPDATE, MODE);
    vfomode[vfosel % 2] = mode;
    paramAction(SAVE, (vfosel % 2) ? MODEB : MODEA);  // save vfoa/b changes
    paramAction(SAVE, MODE);
    paramAction(SAVE, FILTER);
    si5351.iqmsa = 0;  // enforce PLL reset
    if ((prev_mode == CW) && (cwdec))
      show_banner();
    change = true;
  }
  else
  {
    if (menumode == 1) { menumode = 0; }  // short right-click while in menu:
enter value selection screen if (menumode >= 2) { menumode = 1; change = true;
paramAction(SAVE, menu); } // short right-click while in value selection screen:
save, and return to menu screen
  }
  return 1;
}
*/


    //#define _MSC  (F_XTAL/128)   
    /*! MSC exact multiple of F_XTAL (and
     * maximized to fit in max. span 1048575) uint32_t msb128 = (_div *
     * (int32_t)df + _mod);
     */

    //#define _MSC  0xFFFFF  
    /*! Old algorithm 114% CPU load, shortcut for a
     * fixed fxtal=27e6 register uint32_t xmsb = (_div * (_fout + (int32_t)df)) %
     * fxtal;  // xmsb = msb * fxtal/(128 * _MSC); uint32_t msb128 = xmsb *
     * 5*(32/32) - (xmsb/32);  // msb128 = xmsb * 159/32, where 159/32 = 128 *
     * 0xFFFFF / fxtal; fxtal=27e6
     */

  /*
    void freq(uint32_t fout, uint16_t i, uint16_t q){  // Set a CLK0,1 to fout
    Hz with phase i, q uint16_t msa; uint32_t msb, msc, msp1, msp2, msp3;
        uint8_t rdiv = 0;             // CLK pin sees fout/(2^rdiv)
        if(fout > 300000000){ i/=3; q/=3; fout/=3; }  // for higher freqs, use
    3rd harmonic if(fout < 500000){ rdiv = 7; fout *= 128; } // Divide by 128
    for fout 4..500kHz

        uint16_t d = (16 * fxtal) / fout;  // Integer part
        //if(fout > 7000000) d = (33 * fxtal) / fout;
        if(fout < 3500000) d = (7 * fxtal) / fout;  // PLL at 189MHz to cover
    160m (freq>1.48MHz) when using 27MHz crystal

        if( (d * (fout - 5000) / fxtal) != (d * (fout + 5000) / fxtal) ) d++; //
    Test if multiplier remains same for freq deviation +/- 5kHz, if not use
    different divider to make same if(d % 2) d++;  // even numbers preferred for
    divider (AN619 p.4 and p.6) bool divby4 = 0; if(fout > 140000000){ d = 4;
    divby4 = 1; } // for f=140..300MHz; AN619; 4.1.3 uint32_t fvcoa = d * fout;
    // Variable PLLA VCO frequency at integer multiple of fout at around
    27MHz*16 = 432MHz msa = fvcoa / fxtal;     // Integer part of vco/fxtal. msa
    must be in range 15..90 msb = ((uint64_t)(fvcoa % fxtal)*_MSC) / fxtal; //
    fractional part msc = _MSC;

        msp1 = 128*msa + 128*msb/msc - 512;
        msp2 = 128*msb - 128*msb/msc * msc;
        msp3 = msc;
        uint8_t pll_regs[8] = { BB1(msp3), BB0(msp3), BB2(msp1), BB1(msp1),
    BB0(msp1), BB2(((msp3 & 0x0F0000)<<4) | msp2), BB1(msp2), BB0(msp2) };
        SendRegister(26+0*8, pll_regs, 8); // Write to PLLA
        SendRegister(26+1*8, pll_regs, 8); // Write to PLLB
        SendRegister(16+6, 0x80); // PLLA in fractional mode; 0x40=FBA_INT;
    0x80=CLK6_PDN SendRegister(16+7, 0x80); // PLLB in fractional mode;
    0x40=FBB_INT; 0x80=CLK7_PDN

        msa = fvcoa / fout;     // Integer part of vco/fout. msa must be in
    range 6..127 (support for integer and initial phase offset)
        //lcd.setCursor(0, 0); lcd.print(fvcoa/fxtal); lcd.print(" ");
    lcd.print(msb); lcd.print(" "); lcd.print(msa); lcd.print(F("     ")); msp1
    = (divby4) ? 0 : (128*msa - 512);     // msp1 and msp2=0, msp3=1, integer
    division msp2 = 0; msp3 = 1; uint8_t ms_regs[8] = { BB1(msp3), BB0(msp3),
    BB2(msp1) | (rdiv<<4) | (divby4*0x0C), BB1(msp1), BB0(msp1), BB2(((msp3 &
    0x0F0000)<<4) | msp2), BB1(msp2), BB0(msp2) }; SendRegister(42+0*8, ms_regs,
    8); // Write to MS0 SendRegister(42+1*8, ms_regs, 8); // Write to MS1
        SendRegister(42+2*8, ms_regs, 8); // Write to MS2
        SendRegister(16+0, 0x0C|3|(0x40*divby4));  // CLK0: 0x0C=PLLA local
    msynth; 3=8mA; 0x40=MS0_INT; 0x80=CLK0_PDN SendRegister(16+1,
    0x0C|3|(0x40*divby4));  // CLK1: 0x0C=PLLA local msynth; 3=8mA;
    0x40=MS1_INT; 0x80=CLK1_PDN SendRegister(16+2, 0x2C|3|(0x40*divby4));  //
    CLK2: 0x2C=PLLB local msynth; 3=8mA; 0x40=MS2_INT; 0x80=CLK2_PDN
        SendRegister(165, i * msa / 90);  // CLK0: I-phase (on change -> Reset
    PLL) SendRegister(166, q * msa / 90);  // CLK1: Q-phase (on change -> Reset
    PLL) if(iqmsa != ((i-q)*msa/90)){ iqmsa = (i-q)*msa/90; SendRegister(177,
    0xA0); } // 0x20 reset PLLA; 0x80 reset PLLB SendRegister(3, 0b11111100); //
    Enable/disable clock

        _fout = fout;  // cache
        _div = d;
        _msa128min512 = fvcoa / fxtal * 128 - 512;
        _msb128=((uint64_t)(fvcoa % fxtal)*_MSC*128) / fxtal;
    }
  */

/*
class SI5351 : public I2C {
public:
 #define SI_I2C_ADDR 0x60  // SI5351A I2C address: 0x60 for SI5351A-B-GT; 0x62
for SI5351A-B-04486-GT; 0x6F for SI5351A-B02075-GT; see here for other variants:
https://www.silabs.com/TimingUtility/timing-download-document.aspx?OPN=Si5351A-B02075-GT&OPNRevision=0&FileType=PublicAddendum
 #define SI_CLK_OE 3     // Register definitions
 #define SI_CLK0_CONTROL 16
 #define SI_CLK1_CONTROL 17
 #define SI_CLK2_CONTROL 18
 #define SI_SYNTH_PLL_A 26
 #define SI_SYNTH_PLL_B 34
 #define SI_SYNTH_MS_0 42
 #define SI_SYNTH_MS_1 50
 #define SI_SYNTH_MS_2 58
 #define SI_CLK0_PHOFF 165
 #define SI_CLK1_PHOFF 166
 #define SI_CLK2_PHOFF 167
 #define SI_PLL_RESET 177
 #define SI_MS_INT 0b01000000  // Clock control
 #define SI_CLK_SRC_PLL_A 0b00000000
 #define SI_CLK_SRC_PLL_B 0b00100000
 #define SI_CLK_SRC_MS 0b00001100
 #define SI_CLK_IDRV_8MA 0b00000011
 #define SI_CLK_INV 0b00010000
 volatile uint32_t fxtal = 27004300;  //myqcx1:27003980 myqcx2:27004900  Actual
crystal frequency of 27MHz XTAL2 for CL = 10pF (default), calibrate your QCX
27MHz crystal frequency here #define SI_PLL_FREQ (16*fxtal)  //900000000, with
432MHz(=16*27M) PLL freq, usable range is 3.46..100MHz

 volatile uint8_t prev_divider;
 volatile int32_t raw_freq;
 volatile uint8_t divider;  // note: because of int8 only freq > 3.6MHz can be
covered for R_DIV=1 volatile uint8_t mult; volatile uint8_t pll_regs[8];
 volatile int32_t iqmsa;
 volatile int32_t pll_freq;   // temporary

 SI5351(){
   init();
   iqmsa = 0;
 }
 uint8_t RecvRegister(uint8_t reg)
 {
   // Data write to set the register address
   start();
   SendByte(SI_I2C_ADDR << 1);
   SendByte(reg);
   stop();
   // Data read to retrieve the data from the set address
   start();
   SendByte((SI_I2C_ADDR << 1) | 1);
   uint8_t data = RecvByte(true);
   stop();
   return data;
 }
 void SendRegister(uint8_t reg, uint8_t data)
 {
   start();
   SendByte(SI_I2C_ADDR << 1);
   SendByte(reg);
   SendByte(data);
   stop();
 }
 // Set up MultiSynth for register reg=MSNA, MNSB, MS0-5 with fractional
divider, num and denom and R divider (for MSn, not for MSNA, MSNB)
 // divider is 15..90 for MSNA, MSNB,  divider is 8..900 (and in addition 4,6
for integer mode) for MS[0-5]
 // num is 0..1,048,575 (0xFFFFF)
 // denom is 0..1,048,575 (0xFFFFF)
 // num = 0, denom = 1 forces an integer value for the divider
 // r_div = 1..128 (1,2,4,8,16,32,64,128)
 void SetupMultisynth(uint8_t reg, uint8_t divider, uint32_t num, uint32_t
denom, uint8_t r_div)
 {
   uint32_t P1; // Synth config register P1
   uint32_t P2; // Synth config register P2
   uint32_t P3; // Synth config register P3

   P1 = (uint32_t)(128 * ((float)num / (float)denom));
   P1 = (uint32_t)(128 * (uint32_t)(divider) + P1 - 512);
   P2 = (uint32_t)(128 * ((float)num / (float)denom));
   P2 = (uint32_t)(128 * num - denom * P2);
   P3 = denom;

   SendRegister(reg + 0, (P3 & 0x0000FF00) >> 8);
   SendRegister(reg + 1, (P3 & 0x000000FF));
   SendRegister(reg + 2, (P1 & 0x00030000) >> 16 | ((int)log2(r_div) << 4) );
   SendRegister(reg + 3, (P1 & 0x0000FF00) >> 8);
   SendRegister(reg + 4, (P1 & 0x000000FF));
   SendRegister(reg + 5, ((P3 & 0x000F0000) >> 12) | ((P2 & 0x000F0000) >> 16));
   SendRegister(reg + 6, (P2 & 0x0000FF00) >> 8);
   SendRegister(reg + 7, (P2 & 0x000000FF));
 }
 inline void SendPLLRegisterBulk()  // fast freq change of PLLB, takes about [ 2
+ 7*(8+1) + 2 ] / 840000 = 80 uS
 {
   start();
   SendByte(SI_I2C_ADDR << 1);
   SendByte(SI_SYNTH_PLL_A + 3);  // Skip the first three pll_regs bytes (first
two always 0xFF and third not often changing
   //SendByte(SI_SYNTH_PLL_B + 3);  // Skip the first three pll_regs bytes
(first two always 0xFF and third not often changing SendByte(pll_regs[3]);
   SendByte(pll_regs[4]);
   SendByte(pll_regs[5]);
   SendByte(pll_regs[6]);
   SendByte(pll_regs[7]);
   stop();
 }

 #define FAST __attribute__((optimize("Ofast")))

 // this function relies on cached (global) variables: divider, mult, raw_freq,
pll_regs inline void FAST freq_calc_fast(int16_t freq_offset) { // freq_offset
is relative to freq set in freq(freq)
   // uint32_t num128 = ((divider * (raw_freq + offset)) % fxtal) *
(float)(0xFFFFF * 128) / fxtal;
   // Above definition (for fxtal=27.00491M) can be optimized by pre-calculating
factor (0xFFFFF*128)/fxtal (=4.97) as integer constant (5) and
   // substracting the rest error factor (0.03). Note that the latter is shifted
left (0.03<<6)=2, while the other term is shifted right (>>6) register int32_t z
= ((divider * (raw_freq + freq_offset)) % fxtal); register int32_t z2 = -(z >>
5); int32_t num128 = (z * 5) + z2;

   // Set up specified PLL with mult, num and denom: mult is 15..90, num128 is
0..128*1,048,575 (128*0xFFFFF), denom is 0..1,048,575 (0xFFFFF) uint32_t P1 =
128 * mult + (num128 / 0xFFFFF) - 512; uint32_t P2 = num128 % 0xFFFFF;
   //pll_regs[0] = 0xFF;
   //pll_regs[1] = 0xFF;
   //pll_regs[2] = (P1 >> 14) & 0x0C;
   pll_regs[3] = P1 >> 8;
   pll_regs[4] = P1;
   pll_regs[5] = 0xF0 | (P2 >> 16);
   pll_regs[6] = P2 >> 8;
   pll_regs[7] = P2;
 }
 uint16_t div(uint32_t num, uint32_t denom, uint32_t* b, uint32_t* c)
 { // returns a + b / c = num / denom, where a is the integer part and b and c
is the optional fractional part 20 bits each (range 0..1048575) uint16_t a = num
/ denom; if(b && c){ uint64_t l = num % denom; l <<= 20; l--;  // l *= 1048575;
     l /= denom;     // normalize
     *b = l;
     *c = 0xFFFFF;    // for simplicity set c to the maximum 1048575
   }
   return a;
 }
 void freq(uint32_t freq, uint8_t i, uint8_t q)
 { // Fout = Fvco / (R * [MSx_a + MSx_b/MSx_c]),  Fvco = Fxtal * [MSPLLx_a +
MSPLLx_b/MSPLLx_c]; MSx as integer reduce spur
   //uint8_t r_div = (freq > (SI_PLL_FREQ/256/1)) ? 1 : (freq >
(SI_PLL_FREQ/256/32)) ? 32 : 128; // helps divider to be in range uint8_t r_div
= (freq < 500000) ? 128 : 1; freq *= r_div;  // take r_div into account, now
freq is in the range 1MHz to 150MHz raw_freq = freq;   // cache frequency
generated by PLL and MS stages (excluding R divider stage); used by
freq_calc_fast()

   divider = SI_PLL_FREQ / freq;  // Calculate the division ratio. 900,000,000
is the maximum internal PLL freq (official range 600..900MHz but can be pushed
to 300MHz..~1200Mhz) if(divider % 2) divider--;  // divider in range 8.. 900
(including 4,6 for integer mode), even numbers preferred. Note that uint8
datatype is used, so 254 is upper limit if( (divider * (freq - 5000) / fxtal) !=
(divider * (freq + 5000) / fxtal) ) divider -= 2; // Test if multiplier remains
same for freq deviation +/- 5kHz, if not use different divider to make same
   pll_freq = divider * freq; // Calculate the pll_freq: the divider * desired
output freq uint32_t num, denom; mult = div(pll_freq, fxtal, &num, &denom); //
Determine the mult to get to the required pll_freq (in the range 15..90)

   // Set up specified PLL with mult, num and denom: mult is 15..90, num is
0..1,048,575 (0xFFFFF), denom is 0..1,048,575 (0xFFFFF)
   // Set up PLL A and PLL B with the calculated  multiplication ratio
   SetupMultisynth(SI_SYNTH_PLL_A, mult, num, denom, 1);
   SetupMultisynth(SI_SYNTH_PLL_B, mult, num, denom, 1);
   //if(denom == 1) SendRegister(22, SI_MSx_INT); // FBA_INT: MSNA operates in
integer mode
   //if(denom == 1) SendRegister(23, SI_MSx_INT); // FBB_INT: MSNB operates in
integer mode
   // Set up MultiSynth 0,1,2 with the calculated divider, from 4, 6..1800.
   // The final R division stage can divide by a power of two, from 1..128
   // if you want to output frequencies below 1MHz, you have to use the final R
division stage SetupMultisynth(SI_SYNTH_MS_0, divider, 0, 1, r_div);
   SetupMultisynth(SI_SYNTH_MS_1, divider, 0, 1, r_div);
   SetupMultisynth(SI_SYNTH_MS_2, divider, 0, 1, r_div);
   //if(prev_divider != divider){ lcd.setCursor(0, 0); lcd.print(divider);
lcd.print(F("     "));
   // Set I/Q phase
   SendRegister(SI_CLK0_PHOFF, i * divider / 90); // one LSB equivalent to a
time delay of Tvco/4 range 0..127 SendRegister(SI_CLK1_PHOFF, q * divider / 90);
// one LSB equivalent to a time delay of Tvco/4 range 0..127
   // Switch on the CLK0, CLK1 output to be PLL A and set multiSynth0,
multiSynth1 input (0x0F = SI_CLK_SRC_MS | SI_CLK_IDRV_8MA)
   SendRegister(SI_CLK0_CONTROL, 0x0F | SI_MS_INT | SI_CLK_SRC_PLL_A);
   SendRegister(SI_CLK1_CONTROL, 0x0F | SI_MS_INT | SI_CLK_SRC_PLL_A);
   // Switch on the CLK2 output to be PLL B and set multiSynth2 input
   SendRegister(SI_CLK2_CONTROL, 0x0F | SI_MS_INT | SI_CLK_SRC_PLL_B);
   SendRegister(SI_CLK_OE, 0b11111100); // Enable CLK1|CLK0
   // Reset the PLL. This causes a glitch in the output. For small changes to
   // the parameters, you don't need to reset the PLL, and there is no glitch
   if((abs(pll_freq - iqmsa) > 16000000L) || divider != prev_divider){
     iqmsa = pll_freq;
     prev_divider = divider;
     SendRegister(SI_PLL_RESET, 0xA0);
   }
   //SendRegister(24, 0b00000000); // CLK3-0 Disable State: CLK2=0 (BE CAREFUL
TO CHANGE THIS!!!), CLK1/0=00 -> IC4-X0 selected -> 2,5V on IC5A/3(+), when
IC5/2(-) leaks down below 2.5V -> 12V on IC5A/1, IC6A/2(-) -> 0V on IC6A/1,
AUDIO2
 }
 void alt_clk2(uint32_t freq)
 {
   uint32_t num, denom;
   uint16_t mult = div(pll_freq, freq, &num, &denom);

   SetupMultisynth(SI_SYNTH_MS_2, mult, num, denom, 1);

   // Switch on the CLK2 output to be PLL A and set multiSynth2 input
   SendRegister(SI_CLK2_CONTROL, 0x0F | SI_CLK_SRC_PLL_A);

   SendRegister(SI_CLK_OE, 0b11111000); // Enable CLK2|CLK1|CLK0

   //SendRegister(SI_CLK0_PHOFF, 0 * divider / 90); // one LSB equivalent to a
time delay of Tvco/4 range 0..127
   //SendRegister(SI_CLK1_PHOFF, 90 * divider / 90); // one LSB equivalent to a
time delay of Tvco/4 range 0..127
   //SendRegister(SI_CLK2_PHOFF, 45 * divider / 90); // one LSB equivalent to a
time delay of Tvco/4 range 0..127
   //SendRegister(SI_PLL_RESET, 0xA0);
 }
 void powerDown()
 {
   SendRegister(SI_CLK0_CONTROL, 0b10000000);  // Conserve power when output is
disabled SendRegister(SI_CLK1_CONTROL, 0b10000000);
   SendRegister(SI_CLK2_CONTROL, 0b10000000);
   SendRegister(19, 0b10000000);
   SendRegister(20, 0b10000000);
   SendRegister(21, 0b10000000);
   SendRegister(22, 0b10000000);
   SendRegister(23, 0b10000000);
   SendRegister(SI_CLK_OE, 0b11111111); // Disable all CLK outputs
 }
};
static SI5351 si5351;
*/
